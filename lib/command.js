// Generated by CoffeeScript 1.9.2
(function() {
  var BANNER, CoffeeScript, EventEmitter, FakeBlock, SWITCHES, TPA, compileJoin, compileOptions, compilePath, compileScript, compileStdio, exec, exists, failedFiles, fileFinished, forkNode, fs, generatedFiles, helpers, hidden, joinTimeout, notSources, onCompilationFinished, optionParser, optparse, opts, outputPath, parseOptions, path, printLine, printTokens, printWarn, reAddComments, ref, removeSource, runningFiles, setRunningFiles, setTranslatingFile, sourceCode, sources, spawn, timeLog, unwatchDir, usage, useWinPathSep, version, wait, watch, watchDir, watchers, writeJs;

  fs = require('fs');

  path = require('path');

  helpers = require('./helpers');

  optparse = require('./optparse');

  CoffeeScript = require('./coffee-script');

  FakeBlock = require('./compile-with-comments');

  TPA = require('./typescript-property-accumulator');

  reAddComments = require('re-add-comments');

  ref = require('child_process'), spawn = ref.spawn, exec = ref.exec;

  EventEmitter = require('events').EventEmitter;

  require('source-map-support').install();

  setTranslatingFile = require('./helpers').setTranslatingFile;

  exists = fs.exists || path.exists;

  useWinPathSep = path.sep === '\\';

  helpers.extend(CoffeeScript, new EventEmitter);

  printLine = function(line) {
    return process.stdout.write(line + '\n');
  };

  printWarn = function(line) {
    return process.stderr.write(line + '\n');
  };

  hidden = function(file) {
    return /^\.|~$/.test(file);
  };

  BANNER = 'Usage: coffee [options] path/to/script.coffee -- [args]\n\nIf called without options, `coffee` will run your script.';

  SWITCHES = [['-c', '--compile', 'compile to TypeScript and save as .ts files'], ['-h', '--help', 'display this help message'], ['-j', '--join [FILE]', 'concatenate the source CoffeeScript before compiling'], ['-m', '--map', 'generate source map and save as .map files'], ['-n', '--nodes', 'print out the parse tree that the parser produces'], ['-o', '--output [DIR]', 'set the output directory for compiled JavaScript'], ['-p', '--print', 'print out the compiled JavaScript'], ['-s', '--stdio', 'listen for and compile scripts over stdio'], ['-l', '--literate', 'treat stdio as literate style coffee-script'], ['-t', '--tokens', 'print out the tokens that the lexer/rewriter produce'], ['-v', '--version', 'display the version number'], ['-w', '--watch', 'watch scripts for changes and rerun commands'], ['-r', '--ref [FILE]', 'add ///<reference path="[file]" /> to ts files'], ['-d', '--dangerous', 'ignore warnings'], ['-a', '--addcomments', 're-add comments to the output']];

  opts = {};

  sources = [];

  sourceCode = [];

  notSources = {};

  watchers = {};

  optionParser = null;

  failedFiles = [];

  runningFiles = [];

  generatedFiles = [];

  setRunningFiles = function(files) {
    return runningFiles.push.apply(runningFiles, files);
  };

  fileFinished = function(file) {
    runningFiles.splice(runningFiles.indexOf(file), 1);
    if (runningFiles.length === 0) {
      return onCompilationFinished();
    }
  };

  onCompilationFinished = function() {};

  exports.run = function() {
    var j, len, literals, results, source;
    parseOptions();
    helpers.tsReferencePath = opts.ref;
    if (opts.dangerous) {
      helpers.noWarn = true;
    }
    if (opts.nodejs) {
      return forkNode();
    }
    if (opts.help) {
      return usage();
    }
    if (opts.version) {
      return version();
    }
    if (opts.watch && !fs.watch) {
      return printWarn("The --watch feature depends on Node v0.6.0+. You are running " + process.version + ".");
    }
    if (opts.stdio) {
      return compileStdio();
    }
    literals = opts.run ? sources.splice(1) : [];
    process.argv = process.argv.slice(0, 2).concat(literals);
    process.argv[0] = 'coffee';
    onCompilationFinished = function() {
      if (failedFiles.length) {
        return printLine(failedFiles.length + " files failed");
      } else {
        if (generatedFiles.length) {
          return TPA(generatedFiles);
        }
      }
    };
    runningFiles.push.apply(runningFiles, sources);
    results = [];
    for (j = 0, len = sources.length; j < len; j++) {
      source = sources[j];
      results.push(compilePath(source, true, path.normalize(source)));
    }
    return results;
  };

  compilePath = function(source, topLevel, base) {
    return fs.stat(source, function(err, stats) {
      if (err && err.code !== 'ENOENT') {
        throw err;
      }
      if ((err != null ? err.code : void 0) === 'ENOENT') {
        console.error("File not found: " + source);
        process.exit(1);
      }
      if (stats.isDirectory() && path.dirname(source) !== 'node_modules') {
        if (opts.watch) {
          watchDir(source, base);
        }
        return fs.readdir(source, function(err, files) {
          var file, index, ref1, ref2;
          if (err && err.code !== 'ENOENT') {
            throw err;
          }
          if ((err != null ? err.code : void 0) === 'ENOENT') {
            return;
          }
          index = sources.indexOf(source);
          files = files.filter(function(file) {
            return !hidden(file);
          });
          [].splice.apply(sources, [index, index - index + 1].concat(ref1 = (function() {
            var j, len, results;
            results = [];
            for (j = 0, len = files.length; j < len; j++) {
              file = files[j];
              results.push(path.join(source, file));
            }
            return results;
          })())), ref1;
          [].splice.apply(sourceCode, [index, index - index + 1].concat(ref2 = files.map(function() {
            return null;
          }))), ref2;
          return files.forEach(function(file) {
            return compilePath(path.join(source, file), false, base);
          });
        });
      } else if (topLevel || helpers.isCoffee(source)) {
        if (opts.watch) {
          watch(source, base);
        }
        return fs.readFile(source, function(err, code) {
          if (err && err.code !== 'ENOENT') {
            throw err;
          }
          if ((err != null ? err.code : void 0) === 'ENOENT') {
            return;
          }
          return compileScript(source, code.toString(), base);
        });
      } else {
        notSources[source] = true;
        return removeSource(source, base);
      }
    });
  };

  compileScript = function(file, input, base) {
    var compiled, err, message, o, options, output, source, t, task, useColors;
    if (base == null) {
      base = null;
    }
    o = opts;
    options = compileOptions(file, base);
    try {
      t = task = {
        file: file,
        input: input,
        options: options
      };
      CoffeeScript.emit('compile', task);
      if (o.addcomments) {
        source = FakeBlock.makeFakeblocks(t.input);
      } else {
        source = t.input;
      }
      setTranslatingFile(file, source);
      if (o.tokens) {
        printTokens(CoffeeScript.tokens(source, t.options));
      } else if (o.nodes) {
        printLine(CoffeeScript.nodes(source, t.options).toString().trim());
      } else if (o.run) {
        CoffeeScript.run(source, t.options);
      } else if (o.join && t.file !== o.join) {
        if (helpers.isLiterate(file)) {
          t.input = helpers.invertLiterate(t.input);
        }
        sourceCode[sources.indexOf(t.file)] = t.input;
        compileJoin();
      } else {
        compiled = CoffeeScript.compile(source, t.options);
        if (o.addcomments) {
          output = reAddComments(compiled.js, source, compiled.sourceMapHash);
          t.output = FakeBlock.unmakeFakeblocks(output);
        } else {
          t.output = compiled;
          if (o.map) {
            t.output = compiled.js;
            t.sourceMap = compiled.v3SourceMap;
          }
        }
        CoffeeScript.emit('success', task);
        if (o.print) {
          printLine(t.output.trim());
        } else if (o.compile || o.map) {
          writeJs(base, t.file, t.output, options.jsPath, t.sourceMap);
          generatedFiles.push(options.jsPath);
        }
      }
    } catch (_error) {
      err = _error;
      CoffeeScript.emit('failure', err, task);
      if (CoffeeScript.listeners('failure').length) {
        return;
      }
      useColors = process.stdout.isTTY && !process.env.NODE_DISABLE_COLORS;
      message = helpers.prettyErrorMessage(err, file || '[stdin]', input, useColors);
      if (o.watch) {
        printLine(message + '\x07');
      } else {
        printWarn("error compiling " + file);
        printWarn(message);
        failedFiles.push(file);
      }
    }
    return fileFinished(file);
  };

  compileStdio = function() {
    var code, stdin;
    code = '';
    stdin = process.openStdin();
    stdin.on('data', function(buffer) {
      if (buffer) {
        return code += buffer.toString();
      }
    });
    return stdin.on('end', function() {
      return compileScript(null, code);
    });
  };

  joinTimeout = null;

  compileJoin = function() {
    if (!opts.join) {
      return;
    }
    if (!sourceCode.some(function(code) {
      return code === null;
    })) {
      clearTimeout(joinTimeout);
      return joinTimeout = wait(100, function() {
        return compileScript(opts.join, sourceCode.join('\n'), opts.join);
      });
    }
  };

  watch = function(source, base) {
    var compile, compileTimeout, e, prevStats, rewatch, watchErr, watcher;
    prevStats = null;
    compileTimeout = null;
    watchErr = function(e) {
      if (e.code === 'ENOENT') {
        if (sources.indexOf(source) === -1) {
          return;
        }
        try {
          rewatch();
          return compile();
        } catch (_error) {
          e = _error;
          removeSource(source, base, true);
          return compileJoin();
        }
      } else {
        throw e;
      }
    };
    compile = function() {
      clearTimeout(compileTimeout);
      return compileTimeout = wait(25, function() {
        return fs.stat(source, function(err, stats) {
          if (err) {
            return watchErr(err);
          }
          if (prevStats && stats.size === prevStats.size && stats.mtime.getTime() === prevStats.mtime.getTime()) {
            return rewatch();
          }
          prevStats = stats;
          return fs.readFile(source, function(err, code) {
            if (err) {
              return watchErr(err);
            }
            compileScript(source, code.toString(), base);
            return rewatch();
          });
        });
      });
    };
    try {
      watcher = fs.watch(source, compile);
    } catch (_error) {
      e = _error;
      watchErr(e);
    }
    return rewatch = function() {
      if (watcher != null) {
        watcher.close();
      }
      return watcher = fs.watch(source, compile);
    };
  };

  watchDir = function(source, base) {
    var e, readdirTimeout, watcher;
    readdirTimeout = null;
    try {
      return watcher = fs.watch(source, function() {
        clearTimeout(readdirTimeout);
        return readdirTimeout = wait(25, function() {
          return fs.readdir(source, function(err, files) {
            var file, j, len, results;
            if (err) {
              if (err.code !== 'ENOENT') {
                throw err;
              }
              watcher.close();
              return unwatchDir(source, base);
            }
            results = [];
            for (j = 0, len = files.length; j < len; j++) {
              file = files[j];
              if (!(!hidden(file) && !notSources[file])) {
                continue;
              }
              file = path.join(source, file);
              if (sources.some(function(s) {
                return s.indexOf(file) >= 0;
              })) {
                continue;
              }
              sources.push(file);
              sourceCode.push(null);
              results.push(compilePath(file, false, base));
            }
            return results;
          });
        });
      });
    } catch (_error) {
      e = _error;
      if (e.code !== 'ENOENT') {
        throw e;
      }
    }
  };

  unwatchDir = function(source, base) {
    var file, j, len, prevSources, toRemove;
    prevSources = sources.slice(0);
    toRemove = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = sources.length; j < len; j++) {
        file = sources[j];
        if (file.indexOf(source) >= 0) {
          results.push(file);
        }
      }
      return results;
    })();
    for (j = 0, len = toRemove.length; j < len; j++) {
      file = toRemove[j];
      removeSource(file, base, true);
    }
    if (!sources.some(function(s, i) {
      return prevSources[i] !== s;
    })) {
      return;
    }
    return compileJoin();
  };

  removeSource = function(source, base, removeJs) {
    var index, jsPath;
    index = sources.indexOf(source);
    sources.splice(index, 1);
    sourceCode.splice(index, 1);
    if (removeJs && !opts.join) {
      jsPath = outputPath(source, base);
      return exists(jsPath, function(itExists) {
        if (itExists) {
          return fs.unlink(jsPath, function(err) {
            if (err && err.code !== 'ENOENT') {
              throw err;
            }
            return timeLog("removed " + source);
          });
        }
      });
    }
  };

  outputPath = function(source, base, extension) {
    var baseDir, basename, dir, srcDir;
    if (extension == null) {
      extension = ".ts";
    }
    basename = helpers.baseFileName(source, true, useWinPathSep);
    srcDir = path.dirname(source);
    baseDir = base === '.' || base === './' ? srcDir : srcDir.substring(base.length);
    dir = opts.output ? path.join(opts.output, baseDir) : srcDir;
    return path.join(dir, basename + extension);
  };

  writeJs = function(base, sourcePath, js, jsPath, generatedSourceMap) {
    var compile, jsDir, sourceMapPath;
    if (generatedSourceMap == null) {
      generatedSourceMap = null;
    }
    sourceMapPath = outputPath(sourcePath, base, ".map");
    jsDir = path.dirname(jsPath);
    compile = function() {
      if (opts.compile) {
        if (js.length <= 0) {
          js = ' ';
        }
        if (generatedSourceMap) {
          js = js + "\n/*\n//@ sourceMappingURL=" + (helpers.baseFileName(sourceMapPath, false, useWinPathSep)) + "\n*/\n";
        }
        fs.writeFile(jsPath, js, function(err) {
          if (err) {
            return printLine(err.message);
          } else if (opts.compile && opts.watch) {
            return timeLog("compiled " + sourcePath);
          }
        });
      }
      if (generatedSourceMap) {
        return fs.writeFile(sourceMapPath, generatedSourceMap, function(err) {
          if (err) {
            return printLine("Could not write source map: " + err.message);
          }
        });
      }
    };
    return exists(jsDir, function(itExists) {
      if (itExists) {
        return compile();
      } else {
        return exec("mkdir -p " + jsDir, compile);
      }
    });
  };

  wait = function(milliseconds, func) {
    return setTimeout(func, milliseconds);
  };

  timeLog = function(message) {
    return console.log(((new Date).toLocaleTimeString()) + " - " + message);
  };

  printTokens = function(tokens) {
    var strings, tag, token, value;
    strings = (function() {
      var j, len, results;
      results = [];
      for (j = 0, len = tokens.length; j < len; j++) {
        token = tokens[j];
        tag = token[0];
        value = token[1].toString().replace(/\n/, '\\n');
        results.push("[" + tag + " " + value + "]");
      }
      return results;
    })();
    return printLine(strings.join(' '));
  };

  parseOptions = function() {
    var i, j, len, o, source;
    optionParser = new optparse.OptionParser(SWITCHES, BANNER);
    o = opts = optionParser.parse(process.argv.slice(2));
    o.compile || (o.compile = !!o.output);
    o.run = !(o.compile || o.print || o.map);
    o.print = !!(o.print || (o["eval"] || o.stdio && o.compile));
    sources = o["arguments"];
    for (i = j = 0, len = sources.length; j < len; i = ++j) {
      source = sources[i];
      sourceCode[i] = null;
    }
  };

  compileOptions = function(filename, base) {
    var answer, cwd, jsDir, jsPath;
    answer = {
      filename: filename,
      literate: opts.literate || helpers.isLiterate(filename),
      bare: opts.bare,
      header: false,
      sourceMap: opts.map
    };
    if (filename) {
      if (base) {
        cwd = process.cwd();
        jsPath = outputPath(filename, base);
        jsDir = path.dirname(jsPath);
        answer = helpers.merge(answer, {
          jsPath: jsPath,
          sourceRoot: path.relative(jsDir, cwd),
          sourceFiles: [path.relative(cwd, filename)],
          generatedFile: helpers.baseFileName(jsPath, false, useWinPathSep)
        });
      } else {
        answer = helpers.merge(answer, {
          sourceRoot: "",
          sourceFiles: [helpers.baseFileName(filename, false, useWinPathSep)],
          generatedFile: helpers.baseFileName(filename, true, useWinPathSep) + ".ts"
        });
      }
    }
    return answer;
  };

  forkNode = function() {
    var args, nodeArgs;
    nodeArgs = opts.nodejs.split(/\s+/);
    args = process.argv.slice(1);
    args.splice(args.indexOf('--nodejs'), 2);
    return spawn(process.execPath, nodeArgs.concat(args), {
      cwd: process.cwd(),
      env: process.env,
      customFds: [0, 1, 2]
    });
  };

  usage = function() {
    return printLine((new optparse.OptionParser(SWITCHES, BANNER)).help());
  };

  version = function() {
    return printLine("CoffeeScript version " + CoffeeScript.VERSION);
  };

}).call(this);

//# sourceMappingURL=command.js.map
